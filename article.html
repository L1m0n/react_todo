<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>React + Webpack tutorial на русском</title>
	<meta >
	<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,700|Roboto:300,400,700&subset=cyrillic" rel="stylesheet">
	<style>
		body {
			font-family: 'Lora', serif;
			padding: 0;
			margin: 0;
		}
		h1, h2, h3, h4, h5 {
			font-family: 'Open Sans', sans-serif;
			color: #333;
			line-height: 1.6;
			margin: 0 0 15px;
		}
		h1 {
			font-size: 32px;
			text-align: center;
		}
		h2 {
			font-size: 26px;
			margin-top: 20px;
			text-align: left;
		}
		h3 {
			font-size: 22px;
		}
		h4 {
			font-size: 18px;
		}
		p, span, div, li, a {
			font-size: 22px;
			color: #333;
			line-height: 1.5;
			margin-bottom: 10px;
		}
		main {
			max-width: 1024px;
			width: 100%;
			margin: 0 auto;
			padding: 50px 20px;
		}
		.code {
			font-family: 'Open Sans', sans-serif;
			font-size: 18px;
			font-weight: 300;
			color: #fff;
			background: #272822;
			padding: 5px 10px;
			text-align: left;
		}
	</style>
</head>
<body>
	<main>
		<h1>Setting up React for ES6 with Webpack and Babel</h1>
		<p>
			ReactJS берет мир front-end'a штурмом. Описанный на своем сайте, как V в MVC, React позволяет создавать многократно используемые UI компоненты и делает сохранение изменений в состоянии ваших данных легким с помощью абстрагирования DOM. В сочетании со сборщиком Webpack, React значительно упрощает построение и поддержание single page applications.
		</p>
		<p>
			Facebook проделал большую работу по поддержанию React в актуальном состоянии, и даже сделал его совместимым с новыми возможностями от ECMAScript 6 (ES6), значительным обновлением для языка JavaScript, которое наконец-то доступно для использования. К сожалению, поддержка браузером для ES6 не так хороша, как многим хотелось бы, и тут в игру вступают такие удобные утилиты, как Babel. Данная библиотека позволяет нам писать код, который использует новые возможности ES6, а затем компилирует этот код в стандартный ES5 код, который может работать в более старых средах JavaScript. 
		</p>
		<p>
			В этом статье мы пройдем через шаги создания двух основных React компонентов, которые используют ES6 возможности, использовать  Babel чтобы компилировать их в ES5 и собирать проект с помощью Webpack. Это будет весело, потому что React, ES6, Babel и Webpack играют вместе особенно хорошо.
		</p>
		<h2>
			Настраиваем окружение
		</h2>
		<p>
			Перед тем, как начать писать код, мы должны настроить окружение. Сначала убедитесь, что у вас установлен NodeJS. Для установки пакетов будем использовать NPM.
		</p>
		<p>
			После установки NodeJS запускаем терминал и переходим в директорию, где будет находится наш проект и набираеам:
		</p>
		<div class="code">
			npm init
		</div>
		<p>
			Пройдитесь по всем пунутам заполняя информацию, которую вы считаете нужной (можно ничего не заполняя нажимать ентер и потом, когда возникнет необходимость, изменить информацию) и файл package.json должен быть сформирован. Это позволит нам отслеживать, какие node модули  нам нужно для дальнейшего использования.
		</p>
		<p>
			Теперь давайте установим React и React DOM:
		</p>
		<div class="code">
			npm i --save react react-dom
		</div>
		<p>
			Нам также потребуется установить Webpack и Webpack development server для сборки нашего приложения JavaScript. Возможно, вам придется использовать "sudo", чтобы установить dev server глобально.
		</p>
		<div class="code">
			npm i webpack -g<br> 
			npm i webpack-dev-server -g
		</div>
		<p>
			Если Вы будете устанавливать webpack плагины (SASS, minify и т.д.) тогда установить нужно будет вебпак и локально. 
		</p>
		<p>
			Теперь, когда мы установили инструменты сборки, нам понадобится транспилер для интерпретации нашего ES6 кода. Именно для этого нам пригодится Babel. Давайте установим babel-loader и babel-core пакеты, которые мы будем использовать для работы с webpack, а также ES2015 и React пресеты.
		</p>
		<div class="code">
			npm install --save-dev babel-loader <br>
			npm install --save-dev babel-core <br>
			npm install --save-dev babel-preset-es2015 <br>
			npm install --save-dev babel-preset-react 
		</div>
		<h2>
			Создание первых React компонентов
		</h2>
		<p>
			В React компоненты представляют собой отдельные блоки того, как выглядят ваши данные. Вы пишете компоненты для отслеживания того, как ваши данные должны выглядеть и автоматического перерендера при изменении состояния. Когда Вы создаете компонент все это задается в React.Component render функции.
		</p>
		<p>
			Давайте углубимся в это, написав наш первый компонент, чья работа заключается в рендере слова "Hello" в браузере.
		</p>
		<p>
			Откройте новый файл с именем "hello.jsx" в Вашей IDE и введите этот код:
		</p>
		<div class="code">
<pre>
import React from 'react';

class Hello extends React.Component {
  render() {
    return &lt;h1&gt;Hello&lt;/h1&gt;
  }
}
</pre>
		</div>
		<p>
			В синтаксисе есть несколько моментов, которые стоит отметить. Во-первых, у нас есть операторы ES6 импорта и определения классов, что делает наш код более кратким и избавляет от вызова React.createClass. Так же мы видим какой-то странный встроенный HTML в  функции рендера. Этот XML-подобный синтаксис называется JSX. Он был разработан, чтобы сделать создание React компонентов легче, потому что он краток и знаком для определения древовидных структур с атрибутами.
		</p>
		<p>
			Весь этот новый синтаксис может выглядеть немного странно. Но не беспокойтесь, ведь используем Babel, для того, чтобы преобразовать синтаксис ES6 и синтаксис JSX в ES5 JavaScript, который можно запустить в браузере.
		</p>
		<p>
			Вот как наш Hello React компонент выглядит без использования ES6 и JSX:
		</p>
		<div class="code">
<pre>
var React = require('react');
 
var Hello = React.createClass({displayName: 'Hello',
  render: function() {
    return React.createElement("h1", null, "Hello ");
  }
});
</pre>			
		</div>
		<p>
			Когда мы используем JSX, мы можем создать наш виртуальный DOM элемент в сжатой форме без вызова React.createElement и ввода атрибутов которые должен иметь элемент. Наш простой компонент Hello может иметь такое же количество строк кода, но JSX делает вещи намного проще, когда вы будете расщирять компоненты и объединить их вместе.
		</p>
		<p>
			Теперь, когда у нас есть класс компонента, нам нужно добавить пару строчек кода, чтобы "смонтировать" ("mount") этот компонент в DOM элемент. Это возьмет наш React компонент и отобразит его в качестве элемента HTML страницы. Для этого мы импортируем ReactDOM и вызываем его функцию рендера, в которую передаем первым аргументом компонент, а вторым DOM элемент, который будет его содержать.
		</p>
		<p>
			Откройте "hello.jsx" и добавьте эти строки:
		</p>
		<div class="code">
<pre>
import React from 'react';
import ReactDOM from 'react-dom';

class Hello extends React.Component {
  render() {
    return &lt;h1&gt;Hello&lt;/h1&gt;;
  }
}

ReactDOM.render(&lt;Hello/&gt;, document.getElementById('hello'));	
</pre>			
		</div>
		<!-- Now let’s create our second component whose job is to render the word “world”. Create a new file called “world.jsx” and add the following code. Notice that it’s eerily similar to the code we wrote for our first component: -->
		<p>
			Теперь давайте создадим наш второй компонент, чья работа заключается в рендере слова "world". Создайте новый файл с именем "world.jsx" и добавьте следующий код. Обратите внимание на то, что это очень напоминает код, который мы написали для нашего первого компонента:
		</p>
		<div class="code">
<pre>
import React from 'react';
import ReactDOM from 'react-dom';

class World extends React.Component {
  render() {
    return &lt;h1&gt;World&lt;/h1&gt;
  }
}

ReactDOM.render(&lt;World/&gt;, document.getElementById('world'));	
</pre>			
		</div>
		<p>
			Таким образом, у нас есть два React компонента, но они нигде не используются. Давайте исправим это, написав простую HTML-страницу, содержащую &lt;DIV&gt; для каждого компонента, которые мы хотим добавить. Создайте файл "index.html" и напишите следующий код:
		</p>
		<div class="code">
<pre>
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Hello React&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="hello"&gt;&lt;/div&gt;
    &lt;div id="world"&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;	
</pre>			
		</div>
		<p>
			Мы создали все, что нам нужно, чтобы отобразить "Hello World" в браузере с помощью React компонентов. Последний шаг к запуску кода - пропустить его через Webpack.
		</p>
		<h2>
			Пакуем с Webpack
		</h2>
		<p>
			Webpack представляет собой сборщик пакетов, который принимает файлы, такие как CSS, изображения или JS с большим количеством зависимостей и превращает их в нечто, что вы можете добавить в веб-страницу. Он использует загрузчики (loaders), которые вы укажете в файле конфигурации, чтобы знать, как компилировать эти файлы. В нашем случае, мы хотим, скомпилировать JSX в JavaScript и ES6 в понятный браузеру код ES5. Мы можем сделать это путем создания файла JavaScript в качестве точки входа для загрузчика трубопровода Webpacks. Webpack будет анализировать этот файл и все последующие зависимости, используемые в коде, чтобы создать сборку, которую Вы подключите в HTML. Чтобы рассказать  Webpack'у о наших React компонентах, все, что нам нужно сделать, это импортировать эти файлы в JS файл.
		</p>
		<p>
			Создайте файл "main.js" и добавте код, импортирующий оба React компонента, которые мы создали:
		</p>
		<div class="code">
<pre>
import Hello from './hello.jsx';
import World from './world.jsx';	
</pre>			
		</div>
		<p>
			Далее нам нужно сказать Webpack, что это будет наша точка входа и какие загрузчики использовать при создании сборки. Мы используем только Babel загрузчик, но мы можем использовать и другие загрузчики, такие как CoffeeScript и SASS.
		</p>
		<p>
			Запускайте свой текстовый редактор и создайте новый файл с именем "webpack.config.js" и добавьте следующую конфигурацию:
		</p>
		<div class="code">
<pre>
var path = require('path');
var webpack = require('webpack');

module.exports = {
  entry: './main.js',
  output: { path: __dirname, filename: 'bundle.js' },
  module: {
    loaders: [
      {
        test: /.jsx?$/,
        loader: 'babel-loader',
        exclude: /node_modules/,
        query: {
          presets: ['es2015', 'react']
        }
      }
    ]
  },
};	
</pre>			
		</div>
		<p>
			И, наконец, нам нужно внести еще одно небольшое изменение в наш HTML, чтобы включить файл "bundle.js", который будет создан, когда мы запускаем Webpack dev server:
		</p>
		<div class="code">
<pre>
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Hello React&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="hello"&gt;&lt;/div&gt;
    &lt;div id="world"&gt;&lt;/div&gt;
    &lt;script src="bundle.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;	
</pre>			
		</div>
		<p>
			Давайте запустим Webpack dev server, чтобы увидеть наши компоненты на странице в действии:
		</p>
		<div class="code">
<pre>
webpack-dev-server --progress --colors	
</pre>
		</div>
		<img src="images/gif.png" alt="React + Webpack">
		<p>
			Смотрите, как ваш терминал оживает в то время как Webpack строит свой код для запуска в браузере. Теперь, когда сервер DEV работает, вы можете перейти к "http://localhost:8080/webpack-dev-server/" в вашем браузере, чтобы увидеть как ваше Hello World React приложение отображается на странице.
		</p>
		<img src="images/hello.png" alt="React tutorial">
		<h2>
			Что дальше?
		</h2>
		<p>
			Мы только что построили два React компонента, используя Babel для JSX и ES6 синтаксиса и скомпилировали их при помощи Webpack. Это может показаться не так много, но это твердый старт на пути к созданию больших SPA приложений. Теперь вы преодоли препятствие из нескольких новых технологий и можете, наконец, начать делать удивительные штуки с React.
		</p>
		<p>
			Если вы хотите погрузиться в создание реалного React приложения, вы можете почитать <a href="https://www.twilio.com/blog/2015/11/reactjs-tutorial-call-monitoring-with-react-express-and-socket-io.html">этот</a> пост. В нем описано как при помощи React написать dashboard для мониторинга телефонных звонков с использованием API Twilio REST.
		</p>
	</main>
</body>
</html>
